# porrocket

A Linux command-line tool that intercepts TCP port bindings and redirects them to Unix domain sockets using LD_PRELOAD.

---

## ⚠️ Disclaimer

**This codebase was primarily generated by Claude Code as an experimental project.** This is a personal tool created for specific use cases and has not been thoroughly tested in production environments.

**Use at your own risk.** This tool:
- Modifies low-level system behavior using `LD_PRELOAD`
- Has not undergone security audits
- May not work with all applications
- Could have unexpected interactions with system libraries
- Is provided as-is without warranty

If you're looking for production-grade solutions, consider:
- Configuring applications to use Unix sockets natively
- Using battle-tested reverse proxies (nginx, socat, etc.)
- Proper network isolation tools

---

## Usage

```bash
porrocket -p <port> -u <socket_path> -- <command>
```

Example:
```bash
porrocket -p 4312 -u /tmp/app.sock -- node server.js
```

This will make the Node.js process bind to `/tmp/app.sock` instead of port 4312.

## How It Works

`porrocket` uses `LD_PRELOAD` to inject a shared library that hooks the `bind()` system call. When the target application attempts to bind to the specified port, our hook library redirects it to bind to a Unix domain socket instead.

## Platform Support

**Linux only** - This tool is designed specifically for Linux and uses `LD_PRELOAD` for library injection.

### What Works

- ✅ Dynamically linked binaries
- ✅ Interpreted languages (Python, Node.js, Ruby, PHP, etc.)
- ✅ Most application servers (nginx, Apache, etc.)
- ✅ Any program using standard POSIX `bind()` calls

### What Doesn't Work

- ❌ Statically linked binaries
- ❌ Binaries with `setuid`/`setgid` bits (security restriction)
- ❌ Programs using `seccomp` or other security sandboxing
- ❌ Programs that don't use the standard `bind()` syscall

### Why Not macOS/Windows?

- **macOS**: System Integrity Protection (SIP) and code signing prevent `DYLD_INSERT_LIBRARIES` from working reliably. Modern macOS uses two-level namespaces which make simple function interposition ineffective.
- **Windows**: Different architecture entirely; would require DLL injection which has similar security restrictions.

## Installation

### Prerequisites

```bash
# Debian/Ubuntu
sudo apt-get update
sudo apt-get install build-essential

# Install Rust (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

### Building from Source

```bash
# Build the release version
cargo build --release

# Install to ~/.cargo/bin (recommended)
cargo install --path porrocket

# Or run directly from build directory
./target/release/porrocket -p 4312 -u /tmp/app.sock -- your-command
```

## Quick Test

See the [examples/](examples/) directory for working server examples.

**Node.js (recommended):**
```bash
# Run the Node.js example
porrocket -p 4312 -u /tmp/node.sock -- node examples/simple_node.js 4312

# Test in another terminal
curl --unix-socket /tmp/node.sock http://localhost/
```

**Python:**
```bash
# Run the Python example
porrocket -p 4312 -u /tmp/python.sock -- python3 examples/simple_python.py 4312

# Test in another terminal
curl --unix-socket /tmp/python.sock http://localhost/
```

Verify it's working:
```bash
# Check that the Unix socket was created
ls -la /tmp/node.sock

# Check that port 4312 is NOT in use
lsof -i :4312  # Should show nothing
```

## Architecture

The project consists of two components:

1. **porrocket** (binary): CLI tool that spawns the target command with the hook library injected via `LD_PRELOAD`
2. **porrocket-hook** (shared library): `.so` file that intercepts `bind()` calls and redirects them to Unix sockets

## Runtime Compatibility

### ✅ Known Working

- **Node.js** - Works well, recommended
- **Python (custom servers)** - Works with manual socket handling (see examples)
- **Simple C/C++ servers** - Usually works
- **Go applications** - Generally works
- **Rust (tokio/std)** - Usually works

### ❌ Known Incompatible

- **Deno** - Strict socket validation prevents compatibility
- **Python http.server** - Crashes on client address logging
- **Static binaries** - No libc to hook
- **Setuid/setgid binaries** - Security restriction
- **Applications with seccomp filters** - May block LD_PRELOAD

**See [examples/README.md](examples/README.md) for detailed compatibility notes and working code samples.**

## Limitations

1. **Only intercepts IPv4 TCP bindings**: Currently only hooks `AF_INET` family bindings
2. **Single port**: Can only redirect one port at a time per invocation
3. **No IPv6 support**: `AF_INET6` bindings are not intercepted
4. **Socket API only**: Only works with applications using standard POSIX socket APIs
5. **No traffic proxying**: The tool only redirects bindings; it doesn't proxy traffic between TCP and Unix sockets. If you need external clients to connect, you'll need a separate proxy/socat setup.
6. **Application compatibility**: Some applications crash when they try to inspect client addresses or perform TCP-specific operations on Unix sockets

## Use Cases

- Running web servers locally without opening network ports
- Testing applications in isolated environments
- Security hardening by forcing socket-based communication
- Container/sandbox scenarios where network isolation is needed
- Development environments where port conflicts are common

## Troubleshooting

### "Hook library not found" error

The binary looks for `libporrocket_hook.so` in the same directory. If you used `cargo install`, both files should be in `~/.cargo/bin/`.

### Library not loading

```bash
# Check if LD_PRELOAD works
LD_PRELOAD=/path/to/libporrocket_hook.so python3 -c "print('test')"

# Check library dependencies
ldd target/release/libporrocket_hook.so
```

### Port still being used

The hook only redirects `bind()` calls for the specific port specified with `-p`. Make sure:
- You're specifying the correct port number
- The application actually uses that port
- The application uses standard socket APIs (not raw syscalls)

## Contributing

Issues and pull requests are welcome, but please understand this is primarily a personal experimental project. Feel free to fork and adapt for your own needs.

## Acknowledgments

This project was created with assistance from Claude (Anthropic) as an exploration of LD_PRELOAD-based system call interception.

## License

MIT
